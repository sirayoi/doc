=== DynamoDBにおける設計の考え方

==== 設計おけるDynamoDBと一般的なRDBの違い
NOTE:: NoSQLとしているが、DynamoDBの特徴のみである可能性あり

[cols="4", options="headers", cols="10,30a,30a,10"]
|===
| データベース | DynamoDB | 一般的なRDB | 補足
| 設計のベース | アクセスパターン（ユーザが必要とするデータパターン） | データモデル（正規化） | －
| 設計時の思想 | 必要なデータパターンをそのまま格納・そのまま取得 | 重複を排除した最小データの格納（正規化）と必要なデータパターンに合わせて加工（テーブル結合・集計等）したデータの取得 | －

| 特徴
| * 適切なデータパータンに対する処理が早い
* 大量のトランザクションの処理が可能（並列スケール可能）
* 上手く格納されていないデータパターンのデータの取得はほぼできない（大変コストがかかる）
* 取得時にデータを加工（テーブル結合・集計等）することはできない 
| * 一般的にNoSQLと比べて処理が遅い
* 大量のトランザクションへの処理には高性能なハード投資が必要となる（垂直スケール可能）
* 複雑なデータパターンでもデータ取得時にクエリの工夫で取得可能
* アプリケーション処理とDB処理を相互に実施するような複雑なトランザクション処理も実施可能
| －

| 主な設計対象 | キー設計のみ（スキーマレス） | スキーマ定義・参照整合性制約の関連などのテーブル設計が必要 | － 

| 最適なテーブル数 | アプリケーションできるだけ少なく（理想は1個） | 正規化された意味のあるデータ毎に１つ | コスト最適化上の設計思想は除く一旦無視

| 最適なワークロード 
| * ソーシャルネットワーク
* ゲーム
* メディア共有
* Internet of Things (IoT) を含む
* ウェブスケールアプリケーション 
| * アドホッククエリ
* データウェアハウス
* OLAP (オンライン分析処理)
| －

|===

==== データモデルとしてのDynamoDBの設計のポイント

NOTE:: パフォーマンス性能やスループット・コスト最適化は一旦範囲外

[cols="4", options="headers", cols="10a,10a,30a,30a"]
|===
2+| 対象 | 役割・注意点 | 補足

2+| テーブル 
| * アクセスパターンに合わせてデータを格納 + 
* 更新処理を行う際に利用 
| アクセスパターンで必要となるデータパターンをそのまま保持
.2+| プライマリキー設計 
| パーティションキー 
| * 【超重要】対象が適切に指定出来て、かつ、パーティションが適切に分割するように設計する[※1]
| アプリケーションで同時処理される可能性のあるデータ同士が異なるパーティションになる
| ソートキー 
| * アプリケーションで同時に処理される可能性のあるデータがソート順で並ぶようにする 
* 特定パーティション内の検索項目として利用できるので、アクセスパターンで抽出したい処理がある場合にうまく抽出できるような値を設定する [※2]
* バージョンコントロールに利用する目的でソートキーにバージョン番号を追加する[※2]
| －

2+| グローバルセカンダリインデックス設計（GSI）
| * 【超重要】複数データの検索処理を行う際に利用
* アクセスパターンを実現するための最適なGSIのパーティションとプライマリキーの設計が重要（各キー設計の注意点はプライマリキーと同様）
* スパースインデックスを利用して、操作対象のデータ量を最小化し処理性能の向上を図る[※3] 
* 多重定義を意識した設計により、1つのGSIで様々なのデータの取得操作を提供できるようにする[※4]
* 多対多の関連を持つデータ構造に対して、基本テーブルのパーティションキーとソートキーを逆に持つGSIを持つことで表現できる（隣接関係のリスト）[※5]
* 基本テーブルに対する更新と参照処理を分散する目的で、レプリカとして基本テーブルと同一のGSIを作成し、利用することも可能
| 強力な整合性のある検索は実施できない

2+| ローカルセカンダリインデックス設計（LSI）
| * 同一パーティションで異なるソートキーで並び替えて処理したい場合の検索処理で利用
| 強力な整合性のある検索も可能、ただし、キャパシティユニットをテーブルと共有するため、並列処理には向かない可能性あり

2+| Amazon DynamoDB Streams + Lambda設計
| * 集計の結果を格納・計算したい場合に利用
| 多少の遅延があっても問題ない場合の利用に限る

|===

==== アプリケーションの操作に対するDynamoDBのAPI利用のポイント

[cols="3", options="headers", cols="10a,30a,30a"]
|===
| 対象 | 推奨ポイント | 非推奨ポイント

| 取得処理 
| * 1件データの取得は、テーブルもしくはGSIに対してプライマリキーを指定してGetItemを利用
* 複数のデータを取得したい場合（トランザクション無し）は、テーブルに対してBatchGetItemを利用
* 複数のデータを取得したい場合（トランザクションあり）は、テーブルに対してTransactGetItemsを利用
* 条件指定の複数検索の場合、GSIに対するQueryを利用（SortKeyによる絞り込みも利用推奨）
| * テーブルに対するScan、全データ取得になるので遅い（最後の手段的扱い）
* （データ量が少ない場合GSIに対するScanはまだまし）

| 更新処理 
| * 1件データの更新処理は、テーブルに対してUpdateItem/DeleteItemを実施
* 複数のデータを更新したい場合（トランザクション無し）は、テーブルに対してBatchWriteItemを利用、一部失敗があり得るので応答の内容をしっかりと確認する
* 複数のデータを取得したい場合（トランザクションあり）は、テーブルに対してTransactWriteItemsを利用、更新対象の変更が事前の想定から変更がないことを更新条件で確認しながら実施する、同じデータに対するAPI操作は1トランザクションに対して1回しか実施できない
* 複数のデータを連続して処理する場合は、パーティションキーが同じデータを連続して実施せず、パーティションの異なるデータを巡回して処理するとよい[※6]
| － 

|===

==== 設計におけるベストプラックティスのイメージや例
[※1]（パーティションキー）ワークロードを分散するパーティションの例:: （作成中）

[※2]（ソートキー）絞り込みとバージョンコントロールを活用するイメージ:: （作成中）

[※3]（GSI）スパースインデックスを利用した処理性能向上のイメージ:: （作成中）

[※4]（GSI）多重定義のイメージ:: （作成中）

[※5]（GSI）多対多のデータ構造に対する隣接関係のリストのイメージ:: （作成中）

[※6] 連続更新処理の実行順番の効率化のイメージ:: （作成中）

==== DynamoDB の Well-Architected レンズ
（確認中）